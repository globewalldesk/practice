The general strategy is to cycle through games, counting wins and losses;
first generate a board, then let the player place his pieces on the board;
flip a coin; then take turns.

What objects/classes seem necessary? There's the board, obviously, player's
and computer's. There's also the game. Well, I guess I'll have to dive in
and see.

# X generate 10 x 10 board
# cycle through five pieces (ships 5, 4, 3, 3, 2 pieces long)
# orient each randomly (horizontally or vertically)
# randomly choose a position
# test to see if it's legal; if so, save its position
# otherwise randomly choose another position

# let user place his pieces on his board
# cycle through five pieces
# let user choose to orient the piece horizontally or vertically
# show player's current board state
# let player choose topmost or leftmost position of ships
# check for legality
# save if legal, prompt for new position if nothing

# flip coin to see who goes first

# player's move
# show player's representation of computer board
# prompt for player's move
# check for legality
# report if hit or miss
# report if sunk
# redraw player's representation of computer board
# permit player to go again if hit

# computer's move
# if player was most recent to move, say "computer is firing!"
# if computer was most recent to move, say "computer is firing again!"
# if no known unsunk ships, randomly choose target
# if there is a known unsunk ship after hit #1, choose a random direction
# if there is a known unsunk ship after hit >1, choose a direction in line
# with the most recent hits. (careful here! computer follows algorithm to
# determine type of ship that was sunk. At some point the computer must
# choose a direction perpendicular to a line of hits, if necessary.)
# test for legality; choose another if illegal
# determine if hit
# if a hit, determine if hit sinks a ship
# if hit but not sunk, say "hit!"
# if hit and sunk, say "hit and sunk!"
# redraw player's own map
# if hit, take another turn
# if miss, end computer's turn

# test if game is over
# if game is over, announce winner
# if game is not over, toggle active player
# game over: let player choose to see either his or the computer's board
# track overall score, save under username in text file

What boards exist right now? I *think* there's a 'real' board and a 'player view'
board for both the player and the computer. Does this make sense? Of course the
player should see his own *real* board after the computer attacks. The player
should see only the computer's "player view" board after the player attacks.
Of course, the player COULD be shown the "real" view of the computer's board;
but since the player's view of the computer board updates, it's not really
necessary. So the player really only needs two views: player of self and
player of computer.

=============

Bugs:

1. initial view of enemy is labeled "Your Zone" (but this is OK insofar as this view will be removed later).

2. TOP PRIORITY:
test_index > search_for_dot keeps finding a dot (I guess)
In def determine_computer_coords, coords_found keeps getting returned TRUE
by test_index, even when it should be false
Notice the "I guess I didn't find a dot...?" confession...
Notice also that, weirdly, the wrong "ENEMY ZONE" is displayed. Why??

I THINK it has something to do with...player_view not being used or updated
correctly somewhere.

Trackback of "Trying c4. Invalid coordinates: c4":
1. Msg generated by determine_damage because board[y][x] == "#".
2. Sent to determine_damage by computer_turn.
3. Previous in computer_turn, (x,y) were output by determine_computer_coords.
4. In determine_computer_coords, generate_random_coords was not run because
   (it must be) coords_found == true. This is incorrect, it should be false.
5. The only way for coords_found to be true is if it was made true by output
   from test_index.
6. test_index can return "true" for coords_found only if @found == true.
7. @found initially begins as "nil" and can become "true" only in one place,
   viz., in search_for_dot.
8. Within search_for_dot, only FIXED!!!!

======================================

Could go "case..." with '.', '#' as options. If '.' then return as now. But
if '#' then increment and redo. But how do I "redo"? I don't use "goto." I'll
have to take out the logic in question into a method, and run the method again.

==================

Next:
All that's left to do in the main logic of the program is to create
interating_search_left_or_up, along with the supporting logic in search_for_dot.
There is probably a way to do this without copying the logic of
interating_search_right_or_down.

=================

Well, I've finished coding the basic code, but only now do I realize it would be
SO much better to have a certain, different determine_computer_coords
algorithm. It's relatively simple to code, I suspect: give each point on the
board a score, based on the values of its neighbors. Always guess the highest-
scoring item, and if there are more than one that have the same score, then
go ahead and pick the first of the highest that works.

Then it's just a matter of figuring out the weightings. Let's talk about
general principles first:

* Edges are worst, two edges are even worse. Why? Because there are fewer
opportunities for ships to be there. On the other hand, lots of people like
putting their ships on the edges. So this shouldn't be a *strong* principle.

* It is possible that the edge principle is finessed/included if we include
opportunities up to four spots away from the current spot.

* A general rule is: if there is # adjacent to a point, the point gets a
big score boost.

* If there are two consecutive #s to a point, then it gets the biggest score
boost.

Another way would be to give all points a benchmark score, then adjust the
scores for each of the points up and down based on how the non-points are
placed.

============

WAIT, there's a VERY simple algorithm. I should have thought of this first, I
guess.

* The parser goes through all spots systematically.

* It searches in all four directions, up, right, down, and left.

* In each dir, the parser searches until it hits an edge, a sunken ship, or
an x. (If it's an x, a ship couldn't have passed through that spot, so it can
be treated like an edge.)

* But since people like to place their ships next to edges and other ships,
we can give them some points for that; say half the amount as for espots.

* Each empty spot (I'll call them espots) is given, say, 4 points for each
adjacent espot, 3 points for an espot two spots away, 2 points for three spots
away, and 1 point for four spots away. (A sophisticated algorithm would not
grant any more points for four spots away if the carrier has been sunk; etc.
But that hardly seems necessary for this exercise, which is just to get an
algorithm that doesn't seem absolutely idiotic.)

* Hash spots or #s are treated differently. If there is an # adjacent, the
spot gets an enormous boost--much bigger than that given for just being
adjacent to 16 espots. Since 16 espots are worth (on my reckoning) 16+12+8+4=40,
let's say an espot gets 80 if it's next to a hash spot, then 60, 40, and 20 for
any uninterrupted hash spots.

Now the code can be clean. It can be another module. It simply accepts a
player_view, then outputs a hash with the coords pointing to scores. The code
can then use this to print out a handy hint map or of course to pick the best
next place to shoot at.

test_index.rb is 193 lines; I'll bet this can be written in around 50...OK, 100.
I'll call it better_algorithm.rb

============

Getting close to the end of better_algorithm.rb. Might have one or two bugs
left. Not sure the scores (WITHOUT hash spots) are calculated correctly. Biggest
thing needed is to add points for being adjacent to hash spots. That's not done
at all.

=============

Well, no, I was completely off. I have a feeling I only need to fix a few
things, but I don't know what they'd be.

The big problem is that I never *carefully* thought through the algorithm. I
figured I had it mostly.

Given 0,0, search right: 4, 3, 2, 1
search down: 4, 3, 2, 1
search left: now that's the fundamental problem. 0, -1 is defined.
It should be: 0. Same with up.

But given 1,0, right and down will be the same.
Search left now is: 4.

So how do
